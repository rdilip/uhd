<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>USRP Hardware Driver and USRP Manual: uhd::usrp::multi_usrp Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Ettus_Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">USRP Hardware Driver and USRP Manual
   &#160;<span id="projectnumber">Version: 3.11.0.git-162-g2790b51f</span>
   </div>
   <div id="projectbrief">UHD and USRP Manual</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classuhd_1_1usrp_1_1multi__usrp.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classuhd_1_1usrp_1_1multi__usrp-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">uhd::usrp::multi_usrp Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="multi__usrp_8hpp_source.html">uhd/usrp/multi_usrp.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for uhd::usrp::multi_usrp:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classuhd_1_1usrp_1_1multi__usrp.png" usemap="#uhd::usrp::multi_5Fusrp_map" alt=""/>
  <map id="uhd::usrp::multi_5Fusrp_map" name="uhd::usrp::multi_usrp_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuhd_1_1usrp_1_1multi__usrp_1_1register__info__t.html">register_info_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9d9112f5eac0b53a721f2a6c97021fc1"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr&lt; <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">multi_usrp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9d9112f5eac0b53a721f2a6c97021fc1">sptr</a></td></tr>
<tr class="separator:a9d9112f5eac0b53a721f2a6c97021fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6c904057108e52d685b27496a11518db"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a6c904057108e52d685b27496a11518db">~multi_usrp</a> (void)=0</td></tr>
<tr class="separator:a6c904057108e52d685b27496a11518db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac425be38f8e2a3463de440e1f2ae1b6d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1device.html#a439ff67bbcbe999d871a179467355ed0">device::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ac425be38f8e2a3463de440e1f2ae1b6d">get_device</a> (void)=0</td></tr>
<tr class="separator:ac425be38f8e2a3463de440e1f2ae1b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55757381c5114d25f003db7005469fae"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1rx__streamer.html#a7e7fc83d61d3bb68efe296ebc0df9c6d">rx_streamer::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a55757381c5114d25f003db7005469fae">get_rx_stream</a> (const <a class="el" href="structuhd_1_1stream__args__t.html">stream_args_t</a> &amp;args)=0</td></tr>
<tr class="memdesc:a55757381c5114d25f003db7005469fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to get a RX streamer. See also <a class="el" href="classuhd_1_1device.html#a0a9e36f353dcce36b4dd8d394c8813e3" title="Make a new receive streamer from the streamer arguments. ">uhd::device::get_rx_stream()</a>.  <a href="#a55757381c5114d25f003db7005469fae">More...</a><br /></td></tr>
<tr class="separator:a55757381c5114d25f003db7005469fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cda6dd9bec82f11d7883d5f2dca4613"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1tx__streamer.html#a137bfe67e240e3d73ef7708155fb9827">tx_streamer::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a0cda6dd9bec82f11d7883d5f2dca4613">get_tx_stream</a> (const <a class="el" href="structuhd_1_1stream__args__t.html">stream_args_t</a> &amp;args)=0</td></tr>
<tr class="memdesc:a0cda6dd9bec82f11d7883d5f2dca4613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to get a TX streamer. See also <a class="el" href="classuhd_1_1device.html#a0a9e36f353dcce36b4dd8d394c8813e3" title="Make a new receive streamer from the streamer arguments. ">uhd::device::get_rx_stream()</a>.  <a href="#a0cda6dd9bec82f11d7883d5f2dca4613">More...</a><br /></td></tr>
<tr class="separator:a0cda6dd9bec82f11d7883d5f2dca4613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dadf323c5f00ac4f93b231adc13e34c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1dict.html">dict</a>&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1dadf323c5f00ac4f93b231adc13e34c">get_usrp_rx_info</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a1dadf323c5f00ac4f93b231adc13e34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b87120ea1f5d9e9d894843a9416578"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1dict.html">dict</a>&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#af1b87120ea1f5d9e9d894843a9416578">get_usrp_tx_info</a> (size_t chan=0)=0</td></tr>
<tr class="separator:af1b87120ea1f5d9e9d894843a9416578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99254abfa5259b70a020e667eee619b9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a99254abfa5259b70a020e667eee619b9">set_master_clock_rate</a> (double rate, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a99254abfa5259b70a020e667eee619b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefd7580630b2baa4e4c90df3a36d9f0"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aeefd7580630b2baa4e4c90df3a36d9f0">get_master_clock_rate</a> (size_t mboard=0)=0</td></tr>
<tr class="separator:aeefd7580630b2baa4e4c90df3a36d9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22581d58fdf451c3b118add31a6822c"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aa22581d58fdf451c3b118add31a6822c">get_pp_string</a> (void)=0</td></tr>
<tr class="separator:aa22581d58fdf451c3b118add31a6822c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf885b8812408f9ebd471f2902d1cb70"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#abf885b8812408f9ebd471f2902d1cb70">get_mboard_name</a> (size_t mboard=0)=0</td></tr>
<tr class="separator:abf885b8812408f9ebd471f2902d1cb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4bffe3f969c11ee7c0a2cba5178780"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afb4bffe3f969c11ee7c0a2cba5178780">get_time_now</a> (size_t mboard=0)=0</td></tr>
<tr class="separator:afb4bffe3f969c11ee7c0a2cba5178780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ce95415df2de14a048fca5a04ada03"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a55ce95415df2de14a048fca5a04ada03">get_time_last_pps</a> (size_t mboard=0)=0</td></tr>
<tr class="separator:a55ce95415df2de14a048fca5a04ada03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351a2c3081944a0d2caab95e2a2f0926"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a351a2c3081944a0d2caab95e2a2f0926">set_time_now</a> (const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;time_spec, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a351a2c3081944a0d2caab95e2a2f0926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b1c5375549e6a446d686ee7d9b4e14"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a75b1c5375549e6a446d686ee7d9b4e14">set_time_next_pps</a> (const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;time_spec, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a75b1c5375549e6a446d686ee7d9b4e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413014bf3aea4a8ea2d268b4a3b390e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a413014bf3aea4a8ea2d268b4a3b390e9">set_time_unknown_pps</a> (const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;time_spec)=0</td></tr>
<tr class="separator:a413014bf3aea4a8ea2d268b4a3b390e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf70237b38918a4b93c37280f6c648b1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#acf70237b38918a4b93c37280f6c648b1">get_time_synchronized</a> (void)=0</td></tr>
<tr class="separator:acf70237b38918a4b93c37280f6c648b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191b78b00d051d3d51c2f719361c1fb5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a191b78b00d051d3d51c2f719361c1fb5">set_command_time</a> (const <a class="el" href="classuhd_1_1time__spec__t.html">uhd::time_spec_t</a> &amp;time_spec, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a191b78b00d051d3d51c2f719361c1fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607aee766d21228a7aaabde2771eb46f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a607aee766d21228a7aaabde2771eb46f">clear_command_time</a> (size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a607aee766d21228a7aaabde2771eb46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe50c2b24273d1b3b2a343b73609b310"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afe50c2b24273d1b3b2a343b73609b310">issue_stream_cmd</a> (const <a class="el" href="structuhd_1_1stream__cmd__t.html">stream_cmd_t</a> &amp;stream_cmd, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr class="separator:afe50c2b24273d1b3b2a343b73609b310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceddf575752fda1a8cc75513a1178fd9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aceddf575752fda1a8cc75513a1178fd9">set_clock_config</a> (const <a class="el" href="structuhd_1_1clock__config__t.html">clock_config_t</a> &amp;clock_config, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:aceddf575752fda1a8cc75513a1178fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a5580ba06d7d6a037c9ef64f1ea361"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a57a5580ba06d7d6a037c9ef64f1ea361">set_time_source</a> (const std::string &amp;source, const size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a57a5580ba06d7d6a037c9ef64f1ea361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181262333352a82888af00933d07c3cf"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a181262333352a82888af00933d07c3cf">get_time_source</a> (const size_t mboard)=0</td></tr>
<tr class="separator:a181262333352a82888af00933d07c3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee040da1b7ae375e0c08bb0b080d7ccc"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aee040da1b7ae375e0c08bb0b080d7ccc">get_time_sources</a> (const size_t mboard)=0</td></tr>
<tr class="separator:aee040da1b7ae375e0c08bb0b080d7ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ed40009d0d3787c183d42423d25026"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a73ed40009d0d3787c183d42423d25026">set_clock_source</a> (const std::string &amp;source, const size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a73ed40009d0d3787c183d42423d25026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7f679b2f273f7d38eeb1d92e801796"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1e7f679b2f273f7d38eeb1d92e801796">get_clock_source</a> (const size_t mboard)=0</td></tr>
<tr class="separator:a1e7f679b2f273f7d38eeb1d92e801796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1022d151717e49ce69c987bd07b243"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3e1022d151717e49ce69c987bd07b243">get_clock_sources</a> (const size_t mboard)=0</td></tr>
<tr class="separator:a3e1022d151717e49ce69c987bd07b243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60445c1a52e4763b6ebbbfce2db96569"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a60445c1a52e4763b6ebbbfce2db96569">set_clock_source_out</a> (const bool enb, const size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a60445c1a52e4763b6ebbbfce2db96569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1a4bf21fb32bf761204ce0561b5aa7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3a1a4bf21fb32bf761204ce0561b5aa7">set_time_source_out</a> (const bool enb, const size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a3a1a4bf21fb32bf761204ce0561b5aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4efbbc6480fba44939b34c78d44d7e9"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ae4efbbc6480fba44939b34c78d44d7e9">get_num_mboards</a> (void)=0</td></tr>
<tr class="separator:ae4efbbc6480fba44939b34c78d44d7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3c327bcb83fd274e05e3ca95d1ac95"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a2d3c327bcb83fd274e05e3ca95d1ac95">get_mboard_sensor</a> (const std::string &amp;name, size_t mboard=0)=0</td></tr>
<tr class="separator:a2d3c327bcb83fd274e05e3ca95d1ac95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a72259c19b80512dba02e40ed5cf028"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3a72259c19b80512dba02e40ed5cf028">get_mboard_sensor_names</a> (size_t mboard=0)=0</td></tr>
<tr class="separator:a3a72259c19b80512dba02e40ed5cf028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417d8733daa8582957e8de4741ef9ced"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a417d8733daa8582957e8de4741ef9ced">set_user_register</a> (const uint8_t addr, const uint32_t data, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a417d8733daa8582957e8de4741ef9ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f94ed00059cc7dd30567d031b3f9679"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7f94ed00059cc7dd30567d031b3f9679">set_rx_subdev_spec</a> (const <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> &amp;spec, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a7f94ed00059cc7dd30567d031b3f9679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bacd1b1109656d21da6d5e5f8d417c9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a8bacd1b1109656d21da6d5e5f8d417c9">get_rx_subdev_spec</a> (size_t mboard=0)=0</td></tr>
<tr class="separator:a8bacd1b1109656d21da6d5e5f8d417c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac94be28eadeccb9c230ce839e072e3"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afac94be28eadeccb9c230ce839e072e3">get_rx_num_channels</a> (void)=0</td></tr>
<tr class="separator:afac94be28eadeccb9c230ce839e072e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35004bc7e6d418c2c46b2ca0f34db2e6"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a35004bc7e6d418c2c46b2ca0f34db2e6">get_rx_subdev_name</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a35004bc7e6d418c2c46b2ca0f34db2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587cfb5be38a16fec532793b34fbf947"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a587cfb5be38a16fec532793b34fbf947">set_rx_rate</a> (double rate, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr class="separator:a587cfb5be38a16fec532793b34fbf947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf580742d260257bd7e280666423dc9"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9bf580742d260257bd7e280666423dc9">get_rx_rate</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a9bf580742d260257bd7e280666423dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4200ca796a8c70737b180087f8f93c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a6c4200ca796a8c70737b180087f8f93c">get_rx_rates</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a6c4200ca796a8c70737b180087f8f93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b61448f392466e20572fdcb042e8ec6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1tune__result__t.html">tune_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9b61448f392466e20572fdcb042e8ec6">set_rx_freq</a> (const <a class="el" href="structuhd_1_1tune__request__t.html">tune_request_t</a> &amp;tune_request, size_t chan=0)=0</td></tr>
<tr class="separator:a9b61448f392466e20572fdcb042e8ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1c803658f18006efc1dcd67de6d493"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#adb1c803658f18006efc1dcd67de6d493">get_rx_freq</a> (size_t chan=0)=0</td></tr>
<tr class="separator:adb1c803658f18006efc1dcd67de6d493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5ed2146ac31e641839d00a53df784d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9a5ed2146ac31e641839d00a53df784d">get_rx_freq_range</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a9a5ed2146ac31e641839d00a53df784d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63a5b45ca3cc3d74db51a384bba8c2e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ac63a5b45ca3cc3d74db51a384bba8c2e">get_fe_rx_freq_range</a> (size_t chan=0)=0</td></tr>
<tr class="separator:ac63a5b45ca3cc3d74db51a384bba8c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357272d946717da618930d38d11e79e7"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a357272d946717da618930d38d11e79e7">get_rx_lo_names</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a357272d946717da618930d38d11e79e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865f1e3d08802842a73e1f0571110335"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a865f1e3d08802842a73e1f0571110335">set_rx_lo_source</a> (const std::string &amp;src, const std::string &amp;name=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a>, size_t chan=0)=0</td></tr>
<tr class="separator:a865f1e3d08802842a73e1f0571110335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6dd6220be2dad3c9ccde7ca6827662"><td class="memItemLeft" align="right" valign="top">virtual const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4c6dd6220be2dad3c9ccde7ca6827662">get_rx_lo_source</a> (const std::string &amp;name=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a>, size_t chan=0)=0</td></tr>
<tr class="separator:a4c6dd6220be2dad3c9ccde7ca6827662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746916a4d9fb60ae745e354b4ae37d14"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a746916a4d9fb60ae745e354b4ae37d14">get_rx_lo_sources</a> (const std::string &amp;name=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a>, size_t chan=0)=0</td></tr>
<tr class="separator:a746916a4d9fb60ae745e354b4ae37d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c1501c36151e4491b014fed8e7bcda"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ac5c1501c36151e4491b014fed8e7bcda">set_rx_lo_export_enabled</a> (bool enabled, const std::string &amp;name=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a>, size_t chan=0)=0</td></tr>
<tr class="separator:ac5c1501c36151e4491b014fed8e7bcda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4913936cd90ff2be7b659b8b196c4ddf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4913936cd90ff2be7b659b8b196c4ddf">get_rx_lo_export_enabled</a> (const std::string &amp;name=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a>, size_t chan=0)=0</td></tr>
<tr class="separator:a4913936cd90ff2be7b659b8b196c4ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6a2bf7136c0f43b6dcdc51afacbcb5"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3b6a2bf7136c0f43b6dcdc51afacbcb5">set_rx_lo_freq</a> (double freq, const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:a3b6a2bf7136c0f43b6dcdc51afacbcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b262a5a105c3c1babf2017e2c0cf1f8"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3b262a5a105c3c1babf2017e2c0cf1f8">get_rx_lo_freq</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:a3b262a5a105c3c1babf2017e2c0cf1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4466a2e8fe0779962bbe4bb800511e8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ae4466a2e8fe0779962bbe4bb800511e8">get_rx_lo_freq_range</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:ae4466a2e8fe0779962bbe4bb800511e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad602e7681b796deddd9231f022ffef11"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad602e7681b796deddd9231f022ffef11">set_rx_gain</a> (double gain, const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:ad602e7681b796deddd9231f022ffef11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8234968ad1fefef299ef9541cc193915"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a8234968ad1fefef299ef9541cc193915">set_rx_gain</a> (double gain, size_t chan=0)</td></tr>
<tr class="memdesc:a8234968ad1fefef299ef9541cc193915"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper for setting overall RX gain.  <a href="#a8234968ad1fefef299ef9541cc193915">More...</a><br /></td></tr>
<tr class="separator:a8234968ad1fefef299ef9541cc193915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab695b20f1053663669d45669af60f834"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab695b20f1053663669d45669af60f834">set_normalized_rx_gain</a> (double gain, size_t chan=0)=0</td></tr>
<tr class="separator:ab695b20f1053663669d45669af60f834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdab1f6c3775a9071b15c9805f866486"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#abdab1f6c3775a9071b15c9805f866486">set_rx_agc</a> (bool enable, size_t chan=0)=0</td></tr>
<tr class="separator:abdab1f6c3775a9071b15c9805f866486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c406b7964f4cc18dc5b57cafcb345c1"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4c406b7964f4cc18dc5b57cafcb345c1">get_rx_gain</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:a4c406b7964f4cc18dc5b57cafcb345c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6483b85f90a3f46d8181a9b57be1db46"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a6483b85f90a3f46d8181a9b57be1db46">get_rx_gain</a> (size_t chan=0)</td></tr>
<tr class="memdesc:a6483b85f90a3f46d8181a9b57be1db46"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper for getting overall RX gain.  <a href="#a6483b85f90a3f46d8181a9b57be1db46">More...</a><br /></td></tr>
<tr class="separator:a6483b85f90a3f46d8181a9b57be1db46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7ca6681859b985682afc3f353a0631"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a6b7ca6681859b985682afc3f353a0631">get_normalized_rx_gain</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a6b7ca6681859b985682afc3f353a0631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e077fc7331f7675aa796e030bd8a03e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7e077fc7331f7675aa796e030bd8a03e">get_rx_gain_range</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:a7e077fc7331f7675aa796e030bd8a03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb3245ee320e9889a477ba753fd8b8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7eb3245ee320e9889a477ba753fd8b8c">get_rx_gain_range</a> (size_t chan=0)</td></tr>
<tr class="memdesc:a7eb3245ee320e9889a477ba753fd8b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper for getting overall RX gain range.  <a href="#a7eb3245ee320e9889a477ba753fd8b8c">More...</a><br /></td></tr>
<tr class="separator:a7eb3245ee320e9889a477ba753fd8b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496745114d83049ed3d0f5fc96e87b2a"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a496745114d83049ed3d0f5fc96e87b2a">get_rx_gain_names</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a496745114d83049ed3d0f5fc96e87b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b7947cb0c434b98e9915f91b8f8fe0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a72b7947cb0c434b98e9915f91b8f8fe0">set_rx_antenna</a> (const std::string &amp;ant, size_t chan=0)=0</td></tr>
<tr class="separator:a72b7947cb0c434b98e9915f91b8f8fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d35d85aebebfdd2d14cee2850243af"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad2d35d85aebebfdd2d14cee2850243af">get_rx_antenna</a> (size_t chan=0)=0</td></tr>
<tr class="separator:ad2d35d85aebebfdd2d14cee2850243af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1202c5cc978663182adec8c07d8521"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7c1202c5cc978663182adec8c07d8521">get_rx_antennas</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a7c1202c5cc978663182adec8c07d8521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e026819f286e69c48c2e1956d95c6fb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4e026819f286e69c48c2e1956d95c6fb">set_rx_bandwidth</a> (double bandwidth, size_t chan=0)=0</td></tr>
<tr class="separator:a4e026819f286e69c48c2e1956d95c6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d7826c7b96aed88c74ffc035b7f0dd"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a90d7826c7b96aed88c74ffc035b7f0dd">get_rx_bandwidth</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a90d7826c7b96aed88c74ffc035b7f0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71672f89943c87a87f03821e5c185c5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#af71672f89943c87a87f03821e5c185c5">get_rx_bandwidth_range</a> (size_t chan=0)=0</td></tr>
<tr class="separator:af71672f89943c87a87f03821e5c185c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3299d8f77f1d823c762e36438bac509e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1usrp_1_1dboard__iface.html#a59c880b1ce74b17f9aec67426d37a4c8">dboard_iface::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3299d8f77f1d823c762e36438bac509e">get_rx_dboard_iface</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a3299d8f77f1d823c762e36438bac509e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd37d327931cec64e3701eb2a5aa7bfb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#acd37d327931cec64e3701eb2a5aa7bfb">get_rx_sensor</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:acd37d327931cec64e3701eb2a5aa7bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d3d097b6cb1cfa940896e71e5f44ad"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a87d3d097b6cb1cfa940896e71e5f44ad">get_rx_sensor_names</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a87d3d097b6cb1cfa940896e71e5f44ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7beb49c1a04a81b3e7569db482453746"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7beb49c1a04a81b3e7569db482453746">set_rx_dc_offset</a> (const bool enb, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr class="separator:a7beb49c1a04a81b3e7569db482453746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8212c1131a34823430c9bdec9c183f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a8b8212c1131a34823430c9bdec9c183f">set_rx_dc_offset</a> (const std::complex&lt; double &gt; &amp;offset, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr class="separator:a8b8212c1131a34823430c9bdec9c183f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586c52db545664cb2caf830ac90c051e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a586c52db545664cb2caf830ac90c051e">set_rx_iq_balance</a> (const bool enb, size_t chan)=0</td></tr>
<tr class="separator:a586c52db545664cb2caf830ac90c051e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccd212322a5da010ba79f9f18561156"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7ccd212322a5da010ba79f9f18561156">set_rx_iq_balance</a> (const std::complex&lt; double &gt; &amp;correction, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr class="separator:a7ccd212322a5da010ba79f9f18561156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8d9d9fb9a1ec51e81a207cd299e517"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3b8d9d9fb9a1ec51e81a207cd299e517">set_tx_subdev_spec</a> (const <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> &amp;spec, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr class="separator:a3b8d9d9fb9a1ec51e81a207cd299e517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070b4bb3cf27436fb9104a414bc9f3f7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a070b4bb3cf27436fb9104a414bc9f3f7">get_tx_subdev_spec</a> (size_t mboard=0)=0</td></tr>
<tr class="separator:a070b4bb3cf27436fb9104a414bc9f3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be03eb72575c9d5526c93dd133e96d3"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3be03eb72575c9d5526c93dd133e96d3">get_tx_num_channels</a> (void)=0</td></tr>
<tr class="separator:a3be03eb72575c9d5526c93dd133e96d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0632b6ddff26e9d0bd22990274f99d"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4b0632b6ddff26e9d0bd22990274f99d">get_tx_subdev_name</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a4b0632b6ddff26e9d0bd22990274f99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bc17744d3ee94b7c5cdcb75457bd6b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab8bc17744d3ee94b7c5cdcb75457bd6b">set_tx_rate</a> (double rate, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr class="separator:ab8bc17744d3ee94b7c5cdcb75457bd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b75c9dd5ad3c9378f079f4950b043dd"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a2b75c9dd5ad3c9378f079f4950b043dd">get_tx_rate</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a2b75c9dd5ad3c9378f079f4950b043dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36270e66858e63bd8c887fc127782fb5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a36270e66858e63bd8c887fc127782fb5">get_tx_rates</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a36270e66858e63bd8c887fc127782fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a674a9d012a78dd4f2ded478839124"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1tune__result__t.html">tune_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ae7a674a9d012a78dd4f2ded478839124">set_tx_freq</a> (const <a class="el" href="structuhd_1_1tune__request__t.html">tune_request_t</a> &amp;tune_request, size_t chan=0)=0</td></tr>
<tr class="separator:ae7a674a9d012a78dd4f2ded478839124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac9b0e10e67d967c06e8dd6511b5919"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9ac9b0e10e67d967c06e8dd6511b5919">get_tx_freq</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a9ac9b0e10e67d967c06e8dd6511b5919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898502a489319cd64230bb0e50d9ab0a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a898502a489319cd64230bb0e50d9ab0a">get_tx_freq_range</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a898502a489319cd64230bb0e50d9ab0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5418609a1d90f8deb21419bf78fec0f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad5418609a1d90f8deb21419bf78fec0f">get_fe_tx_freq_range</a> (size_t chan=0)=0</td></tr>
<tr class="separator:ad5418609a1d90f8deb21419bf78fec0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cc3c774451d0a2c5f69cd8df0f9f06"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a41cc3c774451d0a2c5f69cd8df0f9f06">set_tx_gain</a> (double gain, const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:a41cc3c774451d0a2c5f69cd8df0f9f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1101dc00b016fe91a299cbcae8b12053"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1101dc00b016fe91a299cbcae8b12053">set_tx_gain</a> (double gain, size_t chan=0)</td></tr>
<tr class="memdesc:a1101dc00b016fe91a299cbcae8b12053"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper for setting overall TX gain.  <a href="#a1101dc00b016fe91a299cbcae8b12053">More...</a><br /></td></tr>
<tr class="separator:a1101dc00b016fe91a299cbcae8b12053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fed2c1b4f34b7c84eb6bb51d189e7e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab0fed2c1b4f34b7c84eb6bb51d189e7e">set_normalized_tx_gain</a> (double gain, size_t chan=0)=0</td></tr>
<tr class="separator:ab0fed2c1b4f34b7c84eb6bb51d189e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88320fb12dd6ebfc4b9f6bc4074f11b"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ae88320fb12dd6ebfc4b9f6bc4074f11b">get_tx_gain</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:ae88320fb12dd6ebfc4b9f6bc4074f11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612c00086f9968380bcf51f877b544b7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a612c00086f9968380bcf51f877b544b7">get_tx_gain</a> (size_t chan=0)</td></tr>
<tr class="memdesc:a612c00086f9968380bcf51f877b544b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper for getting overall TX gain.  <a href="#a612c00086f9968380bcf51f877b544b7">More...</a><br /></td></tr>
<tr class="separator:a612c00086f9968380bcf51f877b544b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa433c396dde24588cece638dd68cb05e"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aa433c396dde24588cece638dd68cb05e">get_normalized_tx_gain</a> (size_t chan=0)=0</td></tr>
<tr class="separator:aa433c396dde24588cece638dd68cb05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99753a578657046f7a0ce72f666abdc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab99753a578657046f7a0ce72f666abdc">get_tx_gain_range</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:ab99753a578657046f7a0ce72f666abdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec9889b9b64d1d8e2a308c0b0c328ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a6ec9889b9b64d1d8e2a308c0b0c328ec">get_tx_gain_range</a> (size_t chan=0)</td></tr>
<tr class="memdesc:a6ec9889b9b64d1d8e2a308c0b0c328ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper for getting overall TX gain range.  <a href="#a6ec9889b9b64d1d8e2a308c0b0c328ec">More...</a><br /></td></tr>
<tr class="separator:a6ec9889b9b64d1d8e2a308c0b0c328ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5589722a2a1491fc393a6b98f094b0"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9f5589722a2a1491fc393a6b98f094b0">get_tx_gain_names</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a9f5589722a2a1491fc393a6b98f094b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8cd16aa93bf3375cdcd3daca3b6b24"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4e8cd16aa93bf3375cdcd3daca3b6b24">set_tx_antenna</a> (const std::string &amp;ant, size_t chan=0)=0</td></tr>
<tr class="separator:a4e8cd16aa93bf3375cdcd3daca3b6b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3e6094ff76cc3d0630e46cb291bcfd"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7f3e6094ff76cc3d0630e46cb291bcfd">get_tx_antenna</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a7f3e6094ff76cc3d0630e46cb291bcfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b10a6bd2128b3810da229c60b31aa1"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a38b10a6bd2128b3810da229c60b31aa1">get_tx_antennas</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a38b10a6bd2128b3810da229c60b31aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04bfc300735435a7937d4eb37e5523d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad04bfc300735435a7937d4eb37e5523d">set_tx_bandwidth</a> (double bandwidth, size_t chan=0)=0</td></tr>
<tr class="separator:ad04bfc300735435a7937d4eb37e5523d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227fd46437f562b8f8f6d4a98cd1c5dc"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a227fd46437f562b8f8f6d4a98cd1c5dc">get_tx_bandwidth</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a227fd46437f562b8f8f6d4a98cd1c5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebc07fa60f37453a8ac3d6ff2fc7aec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#abebc07fa60f37453a8ac3d6ff2fc7aec">get_tx_bandwidth_range</a> (size_t chan=0)=0</td></tr>
<tr class="separator:abebc07fa60f37453a8ac3d6ff2fc7aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3261f1f763a026707dea80ac466d1c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1usrp_1_1dboard__iface.html#a59c880b1ce74b17f9aec67426d37a4c8">dboard_iface::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#abe3261f1f763a026707dea80ac466d1c">get_tx_dboard_iface</a> (size_t chan=0)=0</td></tr>
<tr class="separator:abe3261f1f763a026707dea80ac466d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482d52c0983c6db913209e57f9b79c3a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a482d52c0983c6db913209e57f9b79c3a">get_tx_sensor</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr class="separator:a482d52c0983c6db913209e57f9b79c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a556057ceabc00ab2af61525f206fd"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a33a556057ceabc00ab2af61525f206fd">get_tx_sensor_names</a> (size_t chan=0)=0</td></tr>
<tr class="separator:a33a556057ceabc00ab2af61525f206fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263ab7f0364c03e8a6e330c546769e4f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a263ab7f0364c03e8a6e330c546769e4f">set_tx_dc_offset</a> (const std::complex&lt; double &gt; &amp;offset, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr class="separator:a263ab7f0364c03e8a6e330c546769e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad938e609a11773e21611ee86a0e1b1c5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad938e609a11773e21611ee86a0e1b1c5">set_tx_iq_balance</a> (const std::complex&lt; double &gt; &amp;correction, size_t chan=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a>)=0</td></tr>
<tr class="separator:ad938e609a11773e21611ee86a0e1b1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1c95bbcd0d62af48852a7048393491"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a5e1c95bbcd0d62af48852a7048393491">get_gpio_banks</a> (const size_t mboard)=0</td></tr>
<tr class="separator:a5e1c95bbcd0d62af48852a7048393491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f25d118d20311aca261e6dd252625e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a57f25d118d20311aca261e6dd252625e">set_gpio_attr</a> (const std::string &amp;bank, const std::string &amp;attr, const uint32_t value, const uint32_t mask=0xffffffff, const size_t mboard=0)=0</td></tr>
<tr class="separator:a57f25d118d20311aca261e6dd252625e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8445587e23f5b18eef863e310351dbad"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a8445587e23f5b18eef863e310351dbad">get_gpio_attr</a> (const std::string &amp;bank, const std::string &amp;attr, const size_t mboard=0)=0</td></tr>
<tr class="separator:a8445587e23f5b18eef863e310351dbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7306e1067554a655136b24d6e7c2d9"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1e7306e1067554a655136b24d6e7c2d9">enumerate_registers</a> (const size_t mboard=0)=0</td></tr>
<tr class="separator:a1e7306e1067554a655136b24d6e7c2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ee2f9b43abe490b293e7de2224aaee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1usrp_1_1multi__usrp_1_1register__info__t.html">register_info_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ac8ee2f9b43abe490b293e7de2224aaee">get_register_info</a> (const std::string &amp;path, const size_t mboard=0)=0</td></tr>
<tr class="separator:ac8ee2f9b43abe490b293e7de2224aaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b729c61604ec4569e1e97b6240ec71"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aa0b729c61604ec4569e1e97b6240ec71">write_register</a> (const std::string &amp;path, const uint32_t field, const uint64_t value, const size_t mboard=0)=0</td></tr>
<tr class="separator:aa0b729c61604ec4569e1e97b6240ec71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69a319e44183eac6af490c6da96cc41"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ae69a319e44183eac6af490c6da96cc41">read_register</a> (const std::string &amp;path, const uint32_t field, const size_t mboard=0)=0</td></tr>
<tr class="separator:ae69a319e44183eac6af490c6da96cc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574e7856cd6e01f8eaa4b5936189d874"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a574e7856cd6e01f8eaa4b5936189d874">get_filter_names</a> (const std::string &amp;search_mask=&quot;&quot;)=0</td></tr>
<tr class="separator:a574e7856cd6e01f8eaa4b5936189d874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab058a3c56d12404c962c4399ecb3ed22"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1filter__info__base.html#a61d3390393092ec43475ed3a6c245112">filter_info_base::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab058a3c56d12404c962c4399ecb3ed22">get_filter</a> (const std::string &amp;path)=0</td></tr>
<tr class="separator:ab058a3c56d12404c962c4399ecb3ed22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560768e388cd6494320b72fe9536b0ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a560768e388cd6494320b72fe9536b0ee">set_filter</a> (const std::string &amp;path, <a class="el" href="classuhd_1_1filter__info__base.html#a61d3390393092ec43475ed3a6c245112">filter_info_base::sptr</a> filter)=0</td></tr>
<tr class="separator:a560768e388cd6494320b72fe9536b0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af0d3809a8f8dcd3c962ad5b9a0a6456c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9d9112f5eac0b53a721f2a6c97021fc1">sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#af0d3809a8f8dcd3c962ad5b9a0a6456c">make</a> (const <a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> &amp;dev_addr)</td></tr>
<tr class="separator:af0d3809a8f8dcd3c962ad5b9a0a6456c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a21f2ba01462e1f211a8823fda24a82d5"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a> = size_t(~0)</td></tr>
<tr class="memdesc:a21f2ba01462e1f211a8823fda24a82d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard motherboard index.  <a href="#a21f2ba01462e1f211a8823fda24a82d5">More...</a><br /></td></tr>
<tr class="separator:a21f2ba01462e1f211a8823fda24a82d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeaca319029cb49f7041461345ab641c"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a> = size_t(~0)</td></tr>
<tr class="memdesc:afeaca319029cb49f7041461345ab641c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard channel index.  <a href="#afeaca319029cb49f7041461345ab641c">More...</a><br /></td></tr>
<tr class="separator:afeaca319029cb49f7041461345ab641c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524b7e2177492e59382f1124ee32c12b"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a524b7e2177492e59382f1124ee32c12b">ALL_GAINS</a></td></tr>
<tr class="memdesc:a524b7e2177492e59382f1124ee32c12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard gain element name.  <a href="#a524b7e2177492e59382f1124ee32c12b">More...</a><br /></td></tr>
<tr class="separator:a524b7e2177492e59382f1124ee32c12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5eaa4fb855a52aa97c328ec2fa387b"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a></td></tr>
<tr class="memdesc:a1d5eaa4fb855a52aa97c328ec2fa387b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard gain element name.  <a href="#a1d5eaa4fb855a52aa97c328ec2fa387b">More...</a><br /></td></tr>
<tr class="separator:a1d5eaa4fb855a52aa97c328ec2fa387b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Multi-USRP device class:</p>
<p>This class facilitates ease-of-use for most use-case scenarios. The wrapper provides convenience functions to tune the devices, set the dboard gains, antennas, filters, and other properties. This class can be used to interface with a single USRP with one or more channels, or multiple USRPs in a homogeneous setup. All members take an optional parameter for board number or channel number. In the single device, single channel case, these parameters can be unspecified.</p>
<p>When using a single device with multiple channels:</p><ul>
<li>Channel mapping is determined by the frontend specifications</li>
<li>All channels share a common RX sample rate</li>
<li>All channels share a common TX sample rate</li>
</ul>
<p>When using multiple devices in a configuration:</p><ul>
<li>Channel mapping is determined by the device address arguments</li>
<li>All boards share a common RX sample rate</li>
<li>All boards share a common TX sample rate</li>
<li>All boards share a common RX frontend specification size</li>
<li>All boards share a common TX frontend specification size</li>
<li>All boards must have synchronized times (see the set_time_*() calls)</li>
</ul>
<p>Example to setup channel mapping for multiple devices: </p><pre></pre><pre>//create a <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">multi_usrp</a> with two boards in the configuration
<a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> dev_addr;
dev_addr["addr0"] = "192.168.10.2"
dev_addr["addr1"] = "192.168.10.3";
<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9d9112f5eac0b53a721f2a6c97021fc1">multi_usrp::sptr</a> dev = multi_usrp::make(dev_addr);</pre><pre>//set the board on 10.2 to use the A RX frontend (RX channel 0)
dev-&gt;set_rx_subdev_spec("A:A", 0);</pre><pre>//set the board on 10.3 to use the B RX frontend (RX channel 1)
dev-&gt;set_rx_subdev_spec("A:B", 1);</pre><pre>//set both boards to use the AB TX frontend (TX channels 0 and 1)
dev-&gt;set_tx_subdev_spec("A:AB", <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5" title="A wildcard motherboard index. ">multi_usrp::ALL_MBOARDS</a>);</pre><pre>//now that all the channels are mapped, continue with configuration...</pre><pre></pre> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a9d9112f5eac0b53a721f2a6c97021fc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">multi_usrp</a>&gt; <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9d9112f5eac0b53a721f2a6c97021fc1">uhd::usrp::multi_usrp::sptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6c904057108e52d685b27496a11518db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uhd::usrp::multi_usrp::~multi_usrp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a607aee766d21228a7aaabde2771eb46f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::clear_command_time </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the command time so future commands are sent ASAP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to set the config </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e7306e1067554a655136b24d6e7c2d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::enumerate_registers </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enumerate the full paths of all low-level USRP registers accessible to read/write </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of register paths </dd></dl>

</div>
</div>
<a class="anchor" id="a1e7f679b2f273f7d38eeb1d92e801796"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_clock_source </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the currently set clock source. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to get the config </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string representing the clock source </dd></dl>

</div>
</div>
<a class="anchor" id="a3e1022d151717e49ce69c987bd07b243"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_clock_sources </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible clock sources. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to get the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of strings for possible settings </dd></dl>

</div>
</div>
<a class="anchor" id="ac425be38f8e2a3463de440e1f2ae1b6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1device.html#a439ff67bbcbe999d871a179467355ed0">device::sptr</a> uhd::usrp::multi_usrp::get_device </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the underlying device object. This is needed to get access to the streaming API and properties. </p><dl class="section return"><dt>Returns</dt><dd>the device object within this USRP </dd></dl>

</div>
</div>
<a class="anchor" id="ac63a5b45ca3cc3d74db51a384bba8c2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a> uhd::usrp::multi_usrp::get_fe_rx_freq_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the center frequency range of the RF frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a frequency range object </dd></dl>

</div>
</div>
<a class="anchor" id="ad5418609a1d90f8deb21419bf78fec0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a> uhd::usrp::multi_usrp::get_fe_tx_freq_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the center frequency range of the TX frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a frequency range object </dd></dl>

</div>
</div>
<a class="anchor" id="ab058a3c56d12404c962c4399ecb3ed22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1filter__info__base.html#a61d3390393092ec43475ed3a6c245112">filter_info_base::sptr</a> uhd::usrp::multi_usrp::get_filter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the filter object for the given name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the name of the filter as returned from <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a574e7856cd6e01f8eaa4b5936189d874">get_filter_names()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classuhd_1_1filter__info__base.html#a61d3390393092ec43475ed3a6c245112">filter_info_base::sptr</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a574e7856cd6e01f8eaa4b5936189d874"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_filter_names </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>search_mask</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enumerate the available filters in the signal path. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">search_mask</td><td><p class="starttd">Select only certain filter names by specifying this search mask.</p>
<p class="endtd">E.g. if search mask is set to "rx_frontends/A" only filter names including that string will be returned. </p>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of strings representing the selected filter names. </dd></dl>

</div>
</div>
<a class="anchor" id="a8445587e23f5b18eef863e310351dbad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t uhd::usrp::multi_usrp::get_gpio_attr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a GPIO attribute on a particular GPIO bank. Possible attribute names:</p><ul>
<li>CTRL - 1 for ATR mode 0 for GPIO mode</li>
<li>DDR - 1 for output 0 for input</li>
<li>OUT - GPIO output level (not ATR mode)</li>
<li>ATR_0X - ATR idle state</li>
<li>ATR_RX - ATR receive only state</li>
<li>ATR_TX - ATR transmit only state</li>
<li>ATR_XX - ATR full duplex state</li>
<li>READBACK - readback input GPIOs <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>the name of a GPIO bank </td></tr>
    <tr><td class="paramname">attr</td><td>the name of a GPIO attribute </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value set for this attribute </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a5e1c95bbcd0d62af48852a7048393491"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_gpio_banks </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enumerate gpio banks on the specified device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of string for each bank name </dd></dl>

</div>
</div>
<a class="anchor" id="aeefd7580630b2baa4e4c90df3a36d9f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_master_clock_rate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the master clock rate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the master clock rate in Hz. </dd></dl>

</div>
</div>
<a class="anchor" id="abf885b8812408f9ebd471f2902d1cb70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_mboard_name </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get canonical name for this USRP motherboard. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string representing the name </dd></dl>

</div>
</div>
<a class="anchor" id="a2d3c327bcb83fd274e05e3ca95d1ac95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a> uhd::usrp::multi_usrp::get_mboard_sensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a motherboard sensor value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the sensor </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sensor value object </dd></dl>

</div>
</div>
<a class="anchor" id="a3a72259c19b80512dba02e40ed5cf028"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_mboard_sensor_names </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible motherboard sensor names. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of sensor names </dd></dl>

</div>
</div>
<a class="anchor" id="a6b7ca6681859b985682afc3f353a0631"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_normalized_rx_gain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the normalized RX gain value.</p>
<p>See <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab695b20f1053663669d45669af60f834">set_normalized_rx_gain()</a> for a discussion of normalized gains.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normalized gain (in [0, 1]) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">A</td><td><a class="el" href="structuhd_1_1runtime__error.html">uhd::runtime_error</a> if the gain value is outside [0, 1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa433c396dde24588cece638dd68cb05e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_normalized_tx_gain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the normalized TX gain value.</p>
<p>See <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab695b20f1053663669d45669af60f834">set_normalized_rx_gain()</a> for a discussion of normalized gains.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normalized gain (in [0, 1]) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">A</td><td><a class="el" href="structuhd_1_1runtime__error.html">uhd::runtime_error</a> if the gain value is outside [0, 1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae4efbbc6480fba44939b34c78d44d7e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t uhd::usrp::multi_usrp::get_num_mboards </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of USRP motherboards in this configuration. </p>

</div>
</div>
<a class="anchor" id="aa22581d58fdf451c3b118add31a6822c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_pp_string </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a printable summary for this USRP configuration. </p><dl class="section return"><dt>Returns</dt><dd>a printable string </dd></dl>

</div>
</div>
<a class="anchor" id="ac8ee2f9b43abe490b293e7de2224aaee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1usrp_1_1multi__usrp_1_1register__info__t.html">register_info_t</a> uhd::usrp::multi_usrp::get_register_info </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get more information about a low-level device register </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the full path to the register </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the info struct which contains the bitwidth and read-write access information </dd></dl>

</div>
</div>
<a class="anchor" id="ad2d35d85aebebfdd2d14cee2850243af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_rx_antenna </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the selected RX antenna on the frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the antenna name </dd></dl>

</div>
</div>
<a class="anchor" id="a7c1202c5cc978663182adec8c07d8521"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_rx_antennas </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible RX antennas on the frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of antenna names </dd></dl>

</div>
</div>
<a class="anchor" id="a90d7826c7b96aed88c74ffc035b7f0dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_rx_bandwidth </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the RX bandwidth on the frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bandwidth in Hz </dd></dl>

</div>
</div>
<a class="anchor" id="af71672f89943c87a87f03821e5c185c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a> uhd::usrp::multi_usrp::get_rx_bandwidth_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the range of the possible RX bandwidth settings. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a range of bandwidths in Hz </dd></dl>

</div>
</div>
<a class="anchor" id="a3299d8f77f1d823c762e36438bac509e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1usrp_1_1dboard__iface.html#a59c880b1ce74b17f9aec67426d37a4c8">dboard_iface::sptr</a> uhd::usrp::multi_usrp::get_rx_dboard_iface </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the dboard interface object for the RX frontend. The dboard interface gives access to GPIOs, SPI, I2C, low-speed ADC and DAC. Use at your own risk! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dboard interface sptr </dd></dl>

</div>
</div>
<a class="anchor" id="adb1c803658f18006efc1dcd67de6d493"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_rx_freq </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the RX center frequency. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the frequency in Hz </dd></dl>

</div>
</div>
<a class="anchor" id="a9a5ed2146ac31e641839d00a53df784d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a> uhd::usrp::multi_usrp::get_rx_freq_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the RX center frequency range. This range includes the overall tunable range of the RX chain, including frontend chain and digital down conversion chain. This tunable limit does not include the baseband bandwidth; users should assume that the actual range is +/- samp_rate/2. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a frequency range object </dd></dl>

</div>
</div>
<a class="anchor" id="a4c406b7964f4cc18dc5b57cafcb345c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_rx_gain </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the RX gain value for the specified gain element. For an empty name, sum across all gain elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the gain element </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gain in dB </dd></dl>

</div>
</div>
<a class="anchor" id="a6483b85f90a3f46d8181a9b57be1db46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double uhd::usrp::multi_usrp::get_rx_gain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A convenience wrapper for getting overall RX gain. </p>

</div>
</div>
<a class="anchor" id="a496745114d83049ed3d0f5fc96e87b2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_rx_gain_names </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the names of the gain elements in the RX chain. Gain elements are ordered from antenna to FPGA. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of gain element names </dd></dl>

</div>
</div>
<a class="anchor" id="a7e077fc7331f7675aa796e030bd8a03e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a> uhd::usrp::multi_usrp::get_rx_gain_range </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the RX gain range for the specified gain element. For an empty name, calculate the overall gain range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the gain element </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a gain range object </dd></dl>

</div>
</div>
<a class="anchor" id="a7eb3245ee320e9889a477ba753fd8b8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a> uhd::usrp::multi_usrp::get_rx_gain_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A convenience wrapper for getting overall RX gain range. </p>

</div>
</div>
<a class="anchor" id="a4913936cd90ff2be7b659b8b196c4ddf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool uhd::usrp::multi_usrp::get_rx_lo_export_enabled </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the currently selected LO is being exported. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the LO stage to query </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b262a5a105c3c1babf2017e2c0cf1f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_rx_lo_freq </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the current RX LO frequency (Advanced). If the channel does not have independently configurable LOs the current rf frequency will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the LO stage to query </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the configured LO frequency </dd></dl>

</div>
</div>
<a class="anchor" id="ae4466a2e8fe0779962bbe4bb800511e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a> uhd::usrp::multi_usrp::get_rx_lo_freq_range </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the LO frequency range of the RX LO. If the channel does not have independently configurable LOs the rf frequency range will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the LO stage to query </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a frequency range object </dd></dl>

</div>
</div>
<a class="anchor" id="a357272d946717da618930d38d11e79e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_rx_lo_names </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible LO stage names </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of strings for possible LO names </dd></dl>

</div>
</div>
<a class="anchor" id="a4c6dd6220be2dad3c9ccde7ca6827662"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string uhd::usrp::multi_usrp::get_rx_lo_source </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the currently set LO source. Channels without controllable LO sources will return "internal" </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the LO stage to query </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the configured LO source </dd></dl>

</div>
</div>
<a class="anchor" id="a746916a4d9fb60ae745e354b4ae37d14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_rx_lo_sources </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible LO sources. Channels which do not have controllable LO sources will return "internal". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the LO stage to query </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of strings for possible settings </dd></dl>

</div>
</div>
<a class="anchor" id="afac94be28eadeccb9c230ce839e072e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t uhd::usrp::multi_usrp::get_rx_num_channels </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of RX channels in this configuration. This is the number of USRPs times the number of RX channels per board, where the number of RX channels per board is homogeneous among all USRPs. </p>

</div>
</div>
<a class="anchor" id="a9bf580742d260257bd7e280666423dc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_rx_rate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the RX sample rate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rate in Sps </dd></dl>

</div>
</div>
<a class="anchor" id="a6c4200ca796a8c70737b180087f8f93c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a> uhd::usrp::multi_usrp::get_rx_rates </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a range of possible RX rates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the meta range of rates </dd></dl>

</div>
</div>
<a class="anchor" id="acd37d327931cec64e3701eb2a5aa7bfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a> uhd::usrp::multi_usrp::get_rx_sensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get an RX frontend sensor value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the sensor </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sensor value object </dd></dl>

</div>
</div>
<a class="anchor" id="a87d3d097b6cb1cfa940896e71e5f44ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_rx_sensor_names </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible RX frontend sensor names. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of sensor names </dd></dl>

</div>
</div>
<a class="anchor" id="a55757381c5114d25f003db7005469fae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1rx__streamer.html#a7e7fc83d61d3bb68efe296ebc0df9c6d">rx_streamer::sptr</a> uhd::usrp::multi_usrp::get_rx_stream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1stream__args__t.html">stream_args_t</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method to get a RX streamer. See also <a class="el" href="classuhd_1_1device.html#a0a9e36f353dcce36b4dd8d394c8813e3" title="Make a new receive streamer from the streamer arguments. ">uhd::device::get_rx_stream()</a>. </p>

</div>
</div>
<a class="anchor" id="a35004bc7e6d418c2c46b2ca0f34db2e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_rx_subdev_name </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the name of the RX frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the frontend name </dd></dl>

</div>
</div>
<a class="anchor" id="a8bacd1b1109656d21da6d5e5f8d417c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> uhd::usrp::multi_usrp::get_rx_subdev_spec </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the RX frontend specification. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the frontend specification in use </dd></dl>

</div>
</div>
<a class="anchor" id="a55ce95415df2de14a048fca5a04ada03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> uhd::usrp::multi_usrp::get_time_last_pps </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the time when the last pps pulse occurred. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a timespec representing the last pps </dd></dl>

</div>
</div>
<a class="anchor" id="afb4bffe3f969c11ee7c0a2cba5178780"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> uhd::usrp::multi_usrp::get_time_now </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the current time in the usrp time registers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a timespec representing current usrp time </dd></dl>

</div>
</div>
<a class="anchor" id="a181262333352a82888af00933d07c3cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_time_source </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the currently set time source. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to get the config </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string representing the time source </dd></dl>

</div>
</div>
<a class="anchor" id="aee040da1b7ae375e0c08bb0b080d7ccc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_time_sources </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible time sources. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>which motherboard to get the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of strings for possible settings </dd></dl>

</div>
</div>
<a class="anchor" id="acf70237b38918a4b93c37280f6c648b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool uhd::usrp::multi_usrp::get_time_synchronized </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Are the times across all motherboards in this configuration synchronized? Checks that all time registers are approximately close but not exact, given that the RTT may varying for a control packet transaction. </p><dl class="section return"><dt>Returns</dt><dd>true when all motherboards time registers are in sync </dd></dl>

</div>
</div>
<a class="anchor" id="a7f3e6094ff76cc3d0630e46cb291bcfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_tx_antenna </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the selected TX antenna on the frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the antenna name </dd></dl>

</div>
</div>
<a class="anchor" id="a38b10a6bd2128b3810da229c60b31aa1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_tx_antennas </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible TX antennas on the frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of antenna names </dd></dl>

</div>
</div>
<a class="anchor" id="a227fd46437f562b8f8f6d4a98cd1c5dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_tx_bandwidth </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the TX bandwidth on the frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bandwidth in Hz </dd></dl>

</div>
</div>
<a class="anchor" id="abebc07fa60f37453a8ac3d6ff2fc7aec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a> uhd::usrp::multi_usrp::get_tx_bandwidth_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the range of the possible TX bandwidth settings. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a range of bandwidths in Hz </dd></dl>

</div>
</div>
<a class="anchor" id="abe3261f1f763a026707dea80ac466d1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1usrp_1_1dboard__iface.html#a59c880b1ce74b17f9aec67426d37a4c8">dboard_iface::sptr</a> uhd::usrp::multi_usrp::get_tx_dboard_iface </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the dboard interface object for the TX frontend. The dboard interface gives access to GPIOs, SPI, I2C, low-speed ADC and DAC. Use at your own risk! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dboard interface sptr </dd></dl>

</div>
</div>
<a class="anchor" id="a9ac9b0e10e67d967c06e8dd6511b5919"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_tx_freq </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the TX center frequency. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the frequency in Hz </dd></dl>

</div>
</div>
<a class="anchor" id="a898502a489319cd64230bb0e50d9ab0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceuhd.html#a948ed1f408f7737060d0b6a5d75a135d">freq_range_t</a> uhd::usrp::multi_usrp::get_tx_freq_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the TX center frequency range. This range includes the overall tunable range of the TX chain, including frontend chain and digital up conversion chain. This tunable limit does not include the baseband bandwidth; users should assume that the actual range is +/- samp_rate/2. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a frequency range object </dd></dl>

</div>
</div>
<a class="anchor" id="ae88320fb12dd6ebfc4b9f6bc4074f11b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_tx_gain </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the TX gain value for the specified gain element. For an empty name, sum across all gain elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the gain element </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gain in dB </dd></dl>

</div>
</div>
<a class="anchor" id="a612c00086f9968380bcf51f877b544b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double uhd::usrp::multi_usrp::get_tx_gain </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A convenience wrapper for getting overall TX gain. </p>

</div>
</div>
<a class="anchor" id="a9f5589722a2a1491fc393a6b98f094b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_tx_gain_names </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the names of the gain elements in the TX chain. Gain elements are ordered from antenna to FPGA. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of gain element names </dd></dl>

</div>
</div>
<a class="anchor" id="ab99753a578657046f7a0ce72f666abdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a> uhd::usrp::multi_usrp::get_tx_gain_range </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the TX gain range for the specified gain element. For an empty name, calculate the overall gain range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the gain element </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a gain range object </dd></dl>

</div>
</div>
<a class="anchor" id="a6ec9889b9b64d1d8e2a308c0b0c328ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceuhd.html#ac9b64ecbaa15596e07f58122c82482e3">gain_range_t</a> uhd::usrp::multi_usrp::get_tx_gain_range </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A convenience wrapper for getting overall TX gain range. </p>

</div>
</div>
<a class="anchor" id="a3be03eb72575c9d5526c93dd133e96d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t uhd::usrp::multi_usrp::get_tx_num_channels </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of TX channels in this configuration. This is the number of USRPs times the number of TX channels per board, where the number of TX channels per board is homogeneous among all USRPs. </p>

</div>
</div>
<a class="anchor" id="a2b75c9dd5ad3c9378f079f4950b043dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_tx_rate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the TX sample rate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rate in Sps </dd></dl>

</div>
</div>
<a class="anchor" id="a36270e66858e63bd8c887fc127782fb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1meta__range__t.html">meta_range_t</a> uhd::usrp::multi_usrp::get_tx_rates </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a range of possible TX rates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the meta range of rates </dd></dl>

</div>
</div>
<a class="anchor" id="a482d52c0983c6db913209e57f9b79c3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a> uhd::usrp::multi_usrp::get_tx_sensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get an TX frontend sensor value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the sensor </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sensor value object </dd></dl>

</div>
</div>
<a class="anchor" id="a33a556057ceabc00ab2af61525f206fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_tx_sensor_names </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a list of possible TX frontend sensor names. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of sensor names </dd></dl>

</div>
</div>
<a class="anchor" id="a0cda6dd9bec82f11d7883d5f2dca4613"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1tx__streamer.html#a137bfe67e240e3d73ef7708155fb9827">tx_streamer::sptr</a> uhd::usrp::multi_usrp::get_tx_stream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1stream__args__t.html">stream_args_t</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method to get a TX streamer. See also <a class="el" href="classuhd_1_1device.html#a0a9e36f353dcce36b4dd8d394c8813e3" title="Make a new receive streamer from the streamer arguments. ">uhd::device::get_rx_stream()</a>. </p>

</div>
</div>
<a class="anchor" id="a4b0632b6ddff26e9d0bd22990274f99d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_tx_subdev_name </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the name of the TX frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the frontend name </dd></dl>

</div>
</div>
<a class="anchor" id="a070b4bb3cf27436fb9104a414bc9f3f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> uhd::usrp::multi_usrp::get_tx_subdev_spec </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the TX frontend specification. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the frontend specification in use </dd></dl>

</div>
</div>
<a class="anchor" id="a1dadf323c5f00ac4f93b231adc13e34c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1dict.html">dict</a>&lt;std::string, std::string&gt; uhd::usrp::multi_usrp::get_usrp_rx_info </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns identifying information about this USRP's configuration. Returns motherboard ID, name, and serial. Returns daughterboard RX ID, subdev name and spec, serial, and antenna. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RX info </dd></dl>

</div>
</div>
<a class="anchor" id="af1b87120ea1f5d9e9d894843a9416578"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1dict.html">dict</a>&lt;std::string, std::string&gt; uhd::usrp::multi_usrp::get_usrp_tx_info </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns identifying information about this USRP's configuration. Returns motherboard ID, name, and serial. Returns daughterboard TX ID, subdev name and spec, serial, and antenna. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chan</td><td>channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TX info </dd></dl>

</div>
</div>
<a class="anchor" id="afe50c2b24273d1b3b2a343b73609b310"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::issue_stream_cmd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1stream__cmd__t.html">stream_cmd_t</a> &amp;&#160;</td>
          <td class="paramname"><em>stream_cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Issue a stream command to the usrp device. This tells the usrp to send samples into the host. See the documentation for <a class="el" href="structuhd_1_1stream__cmd__t.html">stream_cmd_t</a> for more info.</p>
<p>With multiple devices, the first stream command in a chain of commands should have a time spec in the near future and stream_now = false; to ensure that the packets can be aligned by their time specs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream_cmd</td><td>the stream command to issue </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0d3809a8f8dcd3c962ad5b9a0a6456c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9d9112f5eac0b53a721f2a6c97021fc1">sptr</a> uhd::usrp::multi_usrp::make </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> &amp;&#160;</td>
          <td class="paramname"><em>dev_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a new multi usrp from the device address. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_addr</td><td>the device address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new single usrp object </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structuhd_1_1key__error.html">uhd::key_error</a></td><td>no device found </td></tr>
    <tr><td class="paramname"><a class="el" href="structuhd_1_1index__error.html">uhd::index_error</a></td><td>fewer devices found than expected </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae69a319e44183eac6af490c6da96cc41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint64_t uhd::usrp::multi_usrp::read_register </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a low-level register field from a register in the USRP hardware </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the full path to the register </td></tr>
    <tr><td class="paramname">field</td><td>the identifier of bitfield to be read </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the register field </dd></dl>

</div>
</div>
<a class="anchor" id="aceddf575752fda1a8cc75513a1178fd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_clock_config </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1clock__config__t.html">clock_config_t</a> &amp;&#160;</td>
          <td class="paramname"><em>clock_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the clock configuration for the usrp device. DEPRECATED in favor of set time and clock source calls. This tells the usrp how to get a 10MHz reference and PPS clock. See the documentation for <a class="el" href="structuhd_1_1clock__config__t.html">clock_config_t</a> for more info. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clock_config</td><td>the clock configuration to set </td></tr>
    <tr><td class="paramname">mboard</td><td>which motherboard to set the config </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73ed40009d0d3787c183d42423d25026"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_clock_source </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the clock source for the usrp device. This sets the source for a 10 MHz reference clock. Typical options for source: internal, external, MIMO. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>a string representing the clock source </td></tr>
    <tr><td class="paramname">mboard</td><td>which motherboard to set the config </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60445c1a52e4763b6ebbbfce2db96569"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_clock_source_out </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send the clock source to an output connector. This call is only applicable on devices with reference outputs. By default, the reference output will be enabled for ease of use. This call may be used to enable or disable the output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enb</td><td>true to output the clock source. </td></tr>
    <tr><td class="paramname">mboard</td><td>which motherboard to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a191b78b00d051d3d51c2f719361c1fb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_command_time </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1time__spec__t.html">uhd::time_spec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>time_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the time at which the control commands will take effect.</p>
<p>A timed command will back-pressure all subsequent timed commands, assuming that the subsequent commands occur within the time-window. If the time spec is late, the command will be activated upon arrival.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_spec</td><td>the time at which the next command will activate </td></tr>
    <tr><td class="paramname">mboard</td><td>which motherboard to set the config </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a560768e388cd6494320b72fe9536b0ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_filter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuhd_1_1filter__info__base.html#a61d3390393092ec43475ed3a6c245112">filter_info_base::sptr</a>&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write back a filter obtained by <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab058a3c56d12404c962c4399ecb3ed22">get_filter()</a> to the signal path. This filter can be a modified version of the originally returned one. The information about Rx or Tx is contained in the path parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the name of the filter as returned from <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a574e7856cd6e01f8eaa4b5936189d874">get_filter_names()</a>. </td></tr>
    <tr><td class="paramname">filter</td><td>the <a class="el" href="classuhd_1_1filter__info__base.html#a61d3390393092ec43475ed3a6c245112">filter_info_base::sptr</a> of the filter object to be written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57f25d118d20311aca261e6dd252625e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_gpio_attr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a GPIO attribute on a particular GPIO bank. Possible attribute names:</p><ul>
<li>CTRL - 1 for ATR mode 0 for GPIO mode</li>
<li>DDR - 1 for output 0 for input</li>
<li>OUT - GPIO output level (not ATR mode)</li>
<li>ATR_0X - ATR idle state</li>
<li>ATR_RX - ATR receive only state</li>
<li>ATR_TX - ATR transmit only state</li>
<li>ATR_XX - ATR full duplex state <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>the name of a GPIO bank </td></tr>
    <tr><td class="paramname">attr</td><td>the name of a GPIO attribute </td></tr>
    <tr><td class="paramname">value</td><td>the new value for this GPIO bank </td></tr>
    <tr><td class="paramname">mask</td><td>the bit mask to effect which pins are changed </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a99254abfa5259b70a020e667eee619b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_master_clock_rate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the master clock rate.</p>
<p>What exactly this changes is device-dependent, but it will always affect the rate at which the ADC/DAC is running.</p>
<p>Like tuning receive or transmit frequencies, this call will do a best effort to change the master clock rate. The device will coerce to the closest clock rate available, and on many devices won't actually change anything at all. Call <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aeefd7580630b2baa4e4c90df3a36d9f0">get_master_clock_rate()</a> to see which rate was actually applied.</p>
<p>Note that changing this value during streaming is not recommended and can have random side effects.</p>
<p>If the device has an 'auto clock rate' setting (e.g. B200, see also <a class="el" href="page_usrp_b200.html#b200_auto_mcr">Automatic Clock Rate Setting</a>), calling this function will disable the automatic clock rate selection, and the clock rate will be fixed to <code>rate</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rate</td><td>the new master clock rate in Hz </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab695b20f1053663669d45669af60f834"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_normalized_rx_gain </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the normalized RX gain value.</p>
<p>The normalized gain is a value in [0, 1], where 0 is the smallest gain value available, and 1 is the largest, independent of the device. In between, gains are linearly interpolated.</p>
<p>Check the individual device manual for notes on the gain range.</p>
<p>Note that it is not possible to specify a gain name for this function, it will always set the overall gain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gain</td><td>the normalized gain value </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">A</td><td><a class="el" href="structuhd_1_1runtime__error.html">uhd::runtime_error</a> if the gain value is outside [0, 1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0fed2c1b4f34b7c84eb6bb51d189e7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_normalized_tx_gain </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the normalized TX gain value.</p>
<p>See <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab695b20f1053663669d45669af60f834">set_normalized_rx_gain()</a> for a discussion on normalized gains.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gain</td><td>the normalized gain value </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">A</td><td><a class="el" href="structuhd_1_1runtime__error.html">uhd::runtime_error</a> if the gain value is outside [0, 1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abdab1f6c3775a9071b15c9805f866486"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_agc </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enable or disable the RX AGC module. Once this module is enabled manual gain settings will be ignored. The AGC will start in a default configuration which should be good for most use cases. Device specific configuration parameters can be found in the property tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Enable or Disable the AGC </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a72b7947cb0c434b98e9915f91b8f8fe0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_antenna </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Select the RX antenna on the frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ant</td><td>the antenna name </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e026819f286e69c48c2e1956d95c6fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_bandwidth </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bandwidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the RX bandwidth on the frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bandwidth</td><td>the bandwidth in Hz </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7beb49c1a04a81b3e7569db482453746"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_dc_offset </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enable/disable the automatic RX DC offset correction. The automatic correction subtracts out the long-run average.</p>
<p>When disabled, the averaging option operation is halted. Once halted, the average value will be held constant until the user re-enables the automatic correction or overrides the value by manually setting the offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enb</td><td>true to enable automatic DC offset correction </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b8212c1131a34823430c9bdec9c183f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_dc_offset </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a constant RX DC offset value. The value is complex to control both I and Q. Only set this when automatic correction is disabled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the dc offset (1.0 is full-scale) </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b61448f392466e20572fdcb042e8ec6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1tune__result__t.html">tune_result_t</a> uhd::usrp::multi_usrp::set_rx_freq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1tune__request__t.html">tune_request_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tune_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the RX center frequency. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tune_request</td><td>tune request instructions </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tune result object </dd></dl>

</div>
</div>
<a class="anchor" id="ad602e7681b796deddd9231f022ffef11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_gain </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the RX gain value for the specified gain element. For an empty name, distribute across all gain elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gain</td><td>the gain in dB </td></tr>
    <tr><td class="paramname">name</td><td>the name of the gain element </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8234968ad1fefef299ef9541cc193915"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uhd::usrp::multi_usrp::set_rx_gain </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A convenience wrapper for setting overall RX gain. </p>

</div>
</div>
<a class="anchor" id="a586c52db545664cb2caf830ac90c051e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_iq_balance </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enable/disable the automatic IQ imbalance correction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enb</td><td>true to enable automatic IQ balance correction </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ccd212322a5da010ba79f9f18561156"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_iq_balance </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>correction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the RX frontend IQ imbalance correction. Use this to adjust the magnitude and phase of I and Q.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">correction</td><td>the complex correction (1.0 is full-scale) </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5c1501c36151e4491b014fed8e7bcda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_lo_export_enabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set whether the LO used by the usrp device is exported For usrps that support exportable LOs, this function configures if the LO used by chan is exported or not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>if true then export the LO </td></tr>
    <tr><td class="paramname">name</td><td>the name of the LO stage to update </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 for the source channel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b6a2bf7136c0f43b6dcdc51afacbcb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::set_rx_lo_freq </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the RX LO frequency (Advanced). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>the frequency to set the LO to </td></tr>
    <tr><td class="paramname">name</td><td>the name of the LO stage to update </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a coerced LO frequency </dd></dl>

</div>
</div>
<a class="anchor" id="a865f1e3d08802842a73e1f0571110335"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_lo_source </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d5eaa4fb855a52aa97c328ec2fa387b">ALL_LOS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the LO source for the usrp device. For usrps that support selectable LOs, this function allows switching between them. Typical options for source: internal, external. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>a string representing the LO source </td></tr>
    <tr><td class="paramname">name</td><td>the name of the LO stage to update </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a587cfb5be38a16fec532793b34fbf947"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_rate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the RX sample rate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rate</td><td>the rate in Sps </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f94ed00059cc7dd30567d031b3f9679"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_subdev_spec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the RX frontend specification: The subdev spec maps a physical part of a daughter-board to a channel number. Set the subdev spec before calling into any methods with a channel number. The subdev spec must be the same size across all motherboards. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spec</td><td>the new frontend specification </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a75b1c5375549e6a446d686ee7d9b4e14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_time_next_pps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>time_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the time registers on the usrp at the next pps tick. The values will not be latched in until the pulse occurs. It is recommended that the user sleep(1) after calling to ensure that the time registers will be in a known state prior to use.</p>
<p>Note: Because this call sets the time on the "next" pps, the seconds in the time spec should be current seconds + 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_spec</td><td>the time to latch into the usrp device </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a351a2c3081944a0d2caab95e2a2f0926"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_time_now </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>time_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the time registers on the usrp immediately.</p>
<p>If only one MIMO master is present in your configuration, set_time_now is safe to use because the slave's time automatically follows the master's time. Otherwise, this call cannot set the time synchronously across multiple devices. Please use the set_time_next_pps or set_time_unknown_pps calls with a PPS signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_spec</td><td>the time to latch into the usrp device </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57a5580ba06d7d6a037c9ef64f1ea361"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_time_source </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the time source for the usrp device. This sets the method of time synchronization, typically a pulse per second or an encoded time. Typical options for source: external, MIMO. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>a string representing the time source </td></tr>
    <tr><td class="paramname">mboard</td><td>which motherboard to set the config </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a1a4bf21fb32bf761204ce0561b5aa7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_time_source_out </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>enb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send the time source to an output connector. This call is only applicable on devices with PPS outputs. By default, the PPS output will be enabled for ease of use. This call may be used to enable or disable the output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enb</td><td>true to output the time source. </td></tr>
    <tr><td class="paramname">mboard</td><td>which motherboard to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a413014bf3aea4a8ea2d268b4a3b390e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_time_unknown_pps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>time_spec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Synchronize the times across all motherboards in this configuration. Use this method to sync the times when the edge of the PPS is unknown.</p>
<p>Ex: Host machine is not attached to serial port of GPSDO and can therefore not query the GPSDO for the PPS edge.</p>
<p>This is a 2-step process, and will take at most 2 seconds to complete. Upon completion, the times will be synchronized to the time provided.</p>
<ul>
<li>Step1: wait for the last pps time to transition to catch the edge</li>
<li>Step2: set the time at the next pps (synchronous for all boards)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_spec</td><td>the time to latch at the next pps after catching the edge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e8cd16aa93bf3375cdcd3daca3b6b24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_antenna </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Select the TX antenna on the frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ant</td><td>the antenna name </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad04bfc300735435a7937d4eb37e5523d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_bandwidth </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>bandwidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the TX bandwidth on the frontend. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bandwidth</td><td>the bandwidth in Hz </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a263ab7f0364c03e8a6e330c546769e4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_dc_offset </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a constant TX DC offset value. The value is complex to control both I and Q. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the dc offset (1.0 is full-scale) </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7a674a9d012a78dd4f2ded478839124"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1tune__result__t.html">tune_result_t</a> uhd::usrp::multi_usrp::set_tx_freq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1tune__request__t.html">tune_request_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tune_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the TX center frequency. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tune_request</td><td>tune request instructions </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tune result object </dd></dl>

</div>
</div>
<a class="anchor" id="a41cc3c774451d0a2c5f69cd8df0f9f06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_gain </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the TX gain value for the specified gain element. For an empty name, distribute across all gain elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gain</td><td>the gain in dB </td></tr>
    <tr><td class="paramname">name</td><td>the name of the gain element </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1101dc00b016fe91a299cbcae8b12053"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uhd::usrp::multi_usrp::set_tx_gain </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A convenience wrapper for setting overall TX gain. </p>

</div>
</div>
<a class="anchor" id="ad938e609a11773e21611ee86a0e1b1c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_iq_balance </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>correction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the TX frontend IQ imbalance correction. Use this to adjust the magnitude and phase of I and Q.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">correction</td><td>the complex correction (1.0 is full-scale) </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8bc17744d3ee94b7c5cdcb75457bd6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_rate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chan</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afeaca319029cb49f7041461345ab641c">ALL_CHANS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the TX sample rate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rate</td><td>the rate in Sps </td></tr>
    <tr><td class="paramname">chan</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b8d9d9fb9a1ec51e81a207cd299e517"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_subdev_spec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> &amp;&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the TX frontend specification: The subdev spec maps a physical part of a daughter-board to a channel number. Set the subdev spec before calling into any methods with a channel number. The subdev spec must be the same size across all motherboards. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spec</td><td>the new frontend specification </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a417d8733daa8582957e8de4741ef9ced"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_user_register </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform write on the user configuration register bus. These only exist if the user has implemented custom setting registers in the device FPGA. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>8-bit register address </td></tr>
    <tr><td class="paramname">data</td><td>32-bit register value </td></tr>
    <tr><td class="paramname">mboard</td><td>which motherboard to set the user register </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0b729c61604ec4569e1e97b6240ec71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::write_register </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>mboard</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a low-level register field for a register in the USRP hardware </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the full path to the register </td></tr>
    <tr><td class="paramname">field</td><td>the identifier of bitfield to be written (all other bits remain unchanged) </td></tr>
    <tr><td class="paramname">value</td><td>the value to write to the register field </td></tr>
    <tr><td class="paramname">mboard</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="afeaca319029cb49f7041461345ab641c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t uhd::usrp::multi_usrp::ALL_CHANS = size_t(~0)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wildcard channel index. </p>

</div>
</div>
<a class="anchor" id="a524b7e2177492e59382f1124ee32c12b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string uhd::usrp::multi_usrp::ALL_GAINS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wildcard gain element name. </p>

</div>
</div>
<a class="anchor" id="a1d5eaa4fb855a52aa97c328ec2fa387b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string uhd::usrp::multi_usrp::ALL_LOS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wildcard gain element name. </p>

</div>
</div>
<a class="anchor" id="a21f2ba01462e1f211a8823fda24a82d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t uhd::usrp::multi_usrp::ALL_MBOARDS = size_t(~0)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wildcard motherboard index. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/uhd/usrp/<a class="el" href="multi__usrp_8hpp_source.html">multi_usrp.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceuhd.html">uhd</a></li><li class="navelem"><a class="el" href="namespaceuhd_1_1usrp.html">usrp</a></li><li class="navelem"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">multi_usrp</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
